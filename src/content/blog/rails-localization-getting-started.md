---
draft: true
author: aergonaut
pubDatetime: 2024-11-08
title: "How to translate your Rails app into over 20 languages"
description: Getting started with Rails app localization
postSlug: crowdin-cli-basic-automation
featured: false
tags:
  - localization
  - automation
---

## Why should you care about localization?

### Definitions

- **Localization (l10n)**: The process of adapting a product or service for use in multiple languages.
- **Locale**: An identifier representing a specific language, optionally with a region and/or script.
- **Internationalization (i18n)**: The process of adapting a product or service for use in multiple languages.

### Why do we care?

If you are just starting out with a new Rails app, you are probably going to use English as the language for your UI text. There are over 1.5 billion English speakers in the world, according to Ethnologue; over 78% of the US population speaks English at home, according to the US Census; and it is the default language file generated by Rails.

English might be good enough when you are just getting started, but that doesn't mean you should stop there.

Consider that there are over 8 billion people in the world's total population. That's nearly 6.5 billion people who do not speak English. If you want to reach those people, you need to make sure your app is available in a language they understand. Even in the US, over 21% of the population speaks a language other than English at home, and over 8% of the population speaks English less than very well. By sticking only to English, you may be unintentionally excluding many people, especially those who may be underserved or excluded from technology due to language.

## So you've decided to localize

### Roadmap

So you've decided to localize your app. Great! But what do you need to do? From a high level, here is your roadmap:

1. Externalize all of your text.
2. Choose your target locales.
3. Translate!
4. Commit and push!
5. Profit!

### Step 1 - Externalize!

The first step is to externalize all of your text. There is a lot more to text externalization than what this post will cover, but the basic idea is to look for anywhere in your application that text appears to users. In a Rails app, this includes obvious places like view templates:

```erb
<h1>Edit User</h1>
```

Or in controllers, such as flash messages:

```rb
flash[:notice] = "Successfully saved."
```

Or even in models, such as error messages:

```rb
errors.add(:title, "cannot be blank")
```

After you've identified some hardcoded text, the next step is to extract it. By default, Rails uses YAML files to store extracted strings, and even generates an `en.yml` in every new app for English. The structure inside a locale file starts with the top-level key, matching the locale code, and then nested under that are keys for each string that needs to be translated:

```yaml
en:
  users:
    edit: "Edit User"
  flash:
    save: "Successfully saved."
```

Finally, we can return to the original files and replace the strings with calls to `I18n.t`, or one of its relatives, depending on the context.

View templates usually use the `t` helper:

```erb
<h1><%= t 'users.edit' %></h1>
```

While controllers usually use `I18n.t`:

```rb
flash[:notice] = I18n.t('flash.save')
```

What we have gained by doing this is now the UI is no longer directly outputting a given piece of text. Instead, the UI is referencing a key that points to the translated string. This means that the UI is able to adapt to different languages by simply providing a locale file with different messages for the same keys. It also means that if you ever need to change the text, you only have one place to do so: the locale file.

### Step 2 - Choose target locales

The next step is to choose your target locales. How you go about this will vary depending on your specific situation, but a good place to start are by asking yourself three questions:

1. What are you company's goals?
2. What are you company's most important regions?
3. Who is your company trying to reach?

If you are a global product, or you have global ambitions, you should start off by asking yourself which international regions you want to target first. From there, you can use a resource like Ethnologue to find out what the most spoken languages are in those regions.

If your main market is the US, you can instead look at data from the US Census. The American Community Survey contains data about what languages people speak at home, and also allows filtering these results based on which respondents said they speak English less than very well. This can help you identify which languages would have the most impact in reaching users who would otherwise not be able to access your app.

Once you have your locales chosen, you need to go through the minor step of converting those locales to locale codes. In most cases, you can simply search Wikipedia, or use an online tool such as the [BCP47 language subtag lookup tool](https://r12a.github.io/app-subtags/index.html) to find the corresponding code. The only other point to be aware of here is that there are a few different standard ways to represent a locale code. If you're unsure, it's probably best to stick to the IETF language tag format, as this is supported by most tools in the web space, but take a moment to investigate the other tools and libraries in your stack to see if there is a preferred format. The most important thing is to be consistent with your locale codes, as it'll make automation much smoother down the line if you don't have to account for different formats.

### Step 3 - Translate!

This is the fun part! Again, depending on your situation, how you approach this might differ.

A bigger enterprise might contract with a language services provider (LSP) to get professional translations. Using professional translators may be important if precision is important to you, for example if you are in a regulated industry, or if you have critical customers. However, professional translators often charge by the word, and prices can add up quickly.

If you're smaller, or you're not ready to contract on a LSP yet, AI-powered machine translation (MT) can be an easier way to get started. There are DIY options, such as the `i18n-tasks` gem which integrated with AI models from OpenAI, Google, DeepL, and more. Or you could go with a localization platform such as Crowdin or Phrase, which provide a more off-the-shelf experience.

For the sake of this post, we'll go the DIY route. First, add the gem to your `Gemfile`:

```rb
gem "i18n-tasks"
```

And run `bundle install`.

Now we can choose an AI provider from one of the ones supported by `i18n-tasks`, create an API key, and set it as an environment variable.

Finally, run `i18n-tasks translate-missing -f en -l <target>` to translate your files! The `-f` flag indicates the source lcoale, in this case English; while the `-l` flag is the target language. You'll have to run this command for each target language. When you're finished, you'll have one YAML file per language.

### Step 4 - Commit and push!

Now it's time to commit and push. But watch out, because locale files can be pretty large, and you might run into some problems. For example:

1. GitHub might reject pushes that are too big
2. The new files might add bloat to your repository
3. The new `String` objects might cause increased memory usage at runtime
4. Your asset bundle size might incrase if you bundle your translations into your frontend code

These are just some of the problems that you might encounter, and you should have monitoring to alert you if any of these become concerning in production.

But assuming none of them are, you've just successfully translated your app!

## Looking ahead

So you've gone through these steps and localized your app. Well, that's just the beginning, because there's still a whole lot more to do. Translating text is just one part of creating an internationalized app. There are too many things to cover in this post, but to give you a taste, here are few you should be looking towards next:

1. Localized formatting, such as for dates (11/19/2024 in the US vs 19/11/2024 in the UK) or numbers (1,337.42 vs 1.337,42)
2. Pluralization rules, such as for languages like Slovak, which has a separate form for groups of 2-4; or Arabic, which has a separate form for pairs
3. Continuous localization, which really just means automating everything we've done so featured
